(
var startup_gui, startup_info, start_but, sg_but, reload_but,
  reload_but_position, load_from_disk, activated_instr, instr_rows,
  tempo_box, tempo_slider, tempo_spec, tempo_coord, midi_stati;

~maindir = "~/dev/frankendank/".standardizePath;
~tempo = 220/60;
sg_but = IdentityDictionary[];
activated_instr = [];

MIDIClient.init;
MIDIIn.connectAll;
~mSrc = ~mSrc ?? IdentityDictionary[];

instr_rows = IdentityDictionary[
  \sax -> 10+0,
  \tuba -> 10+40,
  \drums -> 10+80,
  \com -> 10+120
];

startup_gui = Window("h e r startup", Rect(200, 200, 450, 250));

midi_stati = IdentityDictionary[];
[\sax, \tuba, \drums, \com].do {arg name, i;
  midi_stati[name] = IdentityDictionary[];

  sg_but.put(name,
    Button(startup_gui, Rect(10, 10+(i*40), 80, 30))
      .states_([[name ++ " off"], [name ++ " on"]])
      .mouseDownAction_({
        if (midi_stati[name][\status].notNil) {midi_stati[name][\status].remove};
        midi_stati[name][\status] = StaticText(startup_gui, Rect(100, 10+(i*40), 80, 30));
        if (midi_stati[name][\responder].isNil && ~mSrc[name].isNil) {
          var responder_type; 
          if (name != \com) {responder_type = \program} {responder_type = \noteOn};
          midi_stati[name][\status].stringColor_(Color.red).string_("Awaiting input");
          midi_stati[name][\responder] = MIDIFunc(
            func: {
            arg num, chan, source;
            ~mSrc[name] = source;
            activated_instr.add(name);
            AppClock.sched(0, {
              midi_stati[name][\status].stringColor_(Color.green).string_("Device found");
            });
            midi_stati[name][\responder].free;
            },
            msgType: responder_type
          );
        } {
          midi_stati[name][\responder].free;
          midi_stati[name][\status] = nil;
          midi_stati[name][\responder] = nil;
        };
      })
  );
  reload_but_position = i*40+50;
};

tempo_coord = [200, 10];
tempo_box = NumberBox(startup_gui, Rect(tempo_coord[0] + 50, tempo_coord[1], 50, 30));
StaticText(startup_gui, Rect(tempo_coord[0], tempo_coord[1] + 5, 50, 20))
  .align_(\center).string_("tempo:");
tempo_spec = ControlSpec(50, 220, \linear, 1);
tempo_slider = Slider(startup_gui, Rect(tempo_coord[0], tempo_coord[1] + 35, 220, 40))
                .value_(~tempo)
                .action_({
                  var val = tempo_spec.map(tempo_slider.value);
                  tempo_box.value_(val);
                  ~tempo = val/60;
                });
tempo_box.value_(tempo_spec.map(tempo_slider.value));

reload_but = Button(startup_gui, Rect(10, reload_but_position, 120, 30) )
  .states_( [ ["Reload MIDI IDs", Color.black], ["None Found", Color.red] ] )
  .mouseDownAction_({
    if (~mSrc.isEmpty.not) {
      ~mSrc.keysValuesDo {|instr, id|
        activated_instr.add(instr);
        AppClock.sched(0, {
          midi_stati[instr][\status].stringColor_(Color.green).string_("Device found");
        });
      };
      reload_but.destroy;
      load_from_disk.destroy;
    };
});

load_from_disk = Button(startup_gui, Rect(10, reload_but_position + 40, 120, 30) )
  .states_( [ ["Load From Disk", Color.black], ["No Archive", Color.red] ] )
  .mouseDownAction_({
    ~mSrc = Object.readArchive(~maindir ++ "/archive/mSrc");
    if (~mSrc.notNil) {
      ~mSrc.keysValuesDo {|instr, id|
        activated_instr.add(instr);
        AppClock.sched(0, {
          midi_stati[name][\status] = StaticText(startup_gui, Rect(100, instr_rows[instr], 80, 30));
          midi_stati[instr][\status].stringColor_(Color.green).string_("Device found");
        });
      };
      reload_but.destroy;
      load_from_disk.destroy;
    };
});

start_but = Button(startup_gui, Rect(360, reload_but_position + 40, 80, 30) )
  .states_([["BOOM!", Color.black, Color.red]])
  .mouseDownAction_({
  ~tempo = tempo_spec.map(tempo_slider.value)/60;

  MIDIClient.sources.do {arg source;
    case
    {source.device == "Breath Controller"}  {~mSrc[\breath] = source.uid}
    {source.device == "ControlPad"}         { ~mSrc[\drum_pad] = ~mSrc[\drum_pad] ? source.uid};
  };

  Server.default = s = Server.local;
  s.latency = 0.02;
  s.options = ServerOptions.new.hardwareBufferSize = 256;
  s.waitForBoot({
    ~cond = Condition.new;

    ~clock = TempoClock(~tempo);

    [
      "SD.scd",
      "core.scd",
      "looping.scd",
      "instr/com_sample_map.scd",
      "jams.scd",
      "task_master.scd"
    ].do {|file|
      (~maindir ++ file).load;
      s.sync;
    };

    activated_instr.keysValuesDo {|instr|
      (~maindir++"instr/"++instr++".scd").load
    };

    s.sync(~cond);

    CmdPeriod.doOnce {
      s.freeAll;
      ~clock.clear.stop;
      ~buss.keysValuesDo {|key, value| value.free };
      "busses freed".postln;
      OSCFunc.allEnabled.do {|func| func.free};
      "OSCFuncs freed".postln;
      ~loops.keysValuesDo {|key, value| value.keysValuesDo {|kk, vv| vv[\buffer].free }; };
      "loop freed".postln;
      MIDIdef.freeAll;
      "MIDIdefs freed".postln;
      s.quit;
    };
    ~mSrc.writeArchive(~maindir ++ "/archive/mSrc");

    startup_gui.close;
    ~scheduler.();
  });
});

startup_gui.front;
)
